/*
 * generated by Xtext 2.19.0
 */
package umlrtsyntesizer.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import umlrtsyntesizer.constLang.Addition;
import umlrtsyntesizer.constLang.AndExpression;
import umlrtsyntesizer.constLang.Assign;
import umlrtsyntesizer.constLang.Attribute;
import umlrtsyntesizer.constLang.BoolLiteral;
import umlrtsyntesizer.constLang.ConstLangPackage;
import umlrtsyntesizer.constLang.Context;
import umlrtsyntesizer.constLang.Divide;
import umlrtsyntesizer.constLang.EQ;
import umlrtsyntesizer.constLang.GE;
import umlrtsyntesizer.constLang.GT;
import umlrtsyntesizer.constLang.Identifier;
import umlrtsyntesizer.constLang.Implie;
import umlrtsyntesizer.constLang.Init;
import umlrtsyntesizer.constLang.IntLiteral;
import umlrtsyntesizer.constLang.LE;
import umlrtsyntesizer.constLang.LT;
import umlrtsyntesizer.constLang.MessageConstraint;
import umlrtsyntesizer.constLang.Minus;
import umlrtsyntesizer.constLang.Modulo;
import umlrtsyntesizer.constLang.Multiplication;
import umlrtsyntesizer.constLang.NE;
import umlrtsyntesizer.constLang.NotBooleanExpression;
import umlrtsyntesizer.constLang.OrExpression;
import umlrtsyntesizer.constLang.Param;
import umlrtsyntesizer.constLang.Range;
import umlrtsyntesizer.constLang.RealLiteral;
import umlrtsyntesizer.constLang.SystemInvariant;
import umlrtsyntesizer.constLang.UnaryExpression;
import umlrtsyntesizer.constLang.Value;
import umlrtsyntesizer.services.ConstLangGrammarAccess;

@SuppressWarnings("all")
public class ConstLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ConstLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ConstLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ConstLangPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case ConstLangPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case ConstLangPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case ConstLangPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ConstLangPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case ConstLangPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case ConstLangPackage.DIVIDE:
				sequence_Multiplication(context, (Divide) semanticObject); 
				return; 
			case ConstLangPackage.EQ:
				sequence_ComparisonOperators(context, (EQ) semanticObject); 
				return; 
			case ConstLangPackage.GE:
				sequence_ComparisonOperators(context, (GE) semanticObject); 
				return; 
			case ConstLangPackage.GT:
				sequence_ComparisonOperators(context, (GT) semanticObject); 
				return; 
			case ConstLangPackage.IDENTIFIER:
				sequence_Identifier(context, (Identifier) semanticObject); 
				return; 
			case ConstLangPackage.IMPLIE:
				sequence_Implie(context, (Implie) semanticObject); 
				return; 
			case ConstLangPackage.INIT:
				sequence_Init(context, (Init) semanticObject); 
				return; 
			case ConstLangPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case ConstLangPackage.LE:
				sequence_ComparisonOperators(context, (LE) semanticObject); 
				return; 
			case ConstLangPackage.LT:
				sequence_ComparisonOperators(context, (LT) semanticObject); 
				return; 
			case ConstLangPackage.MESSAGE_CONSTRAINT:
				sequence_MessageConstraint(context, (MessageConstraint) semanticObject); 
				return; 
			case ConstLangPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case ConstLangPackage.MODULO:
				sequence_Multiplication(context, (Modulo) semanticObject); 
				return; 
			case ConstLangPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case ConstLangPackage.NE:
				sequence_ComparisonOperators(context, (NE) semanticObject); 
				return; 
			case ConstLangPackage.NOT_BOOLEAN_EXPRESSION:
				sequence_NotBooleanExpression(context, (NotBooleanExpression) semanticObject); 
				return; 
			case ConstLangPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case ConstLangPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case ConstLangPackage.PARAMETER:
				sequence_Parameter(context, (umlrtsyntesizer.constLang.Parameter) semanticObject); 
				return; 
			case ConstLangPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case ConstLangPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case ConstLangPackage.SYSTEM_INVARIANT:
				sequence_SystemInvariant(context, (SystemInvariant) semanticObject); 
				return; 
			case ConstLangPackage.UNARY_EXPRESSION:
				sequence_Unary(context, (UnaryExpression) semanticObject); 
				return; 
			case ConstLangPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns Addition
	 *     Assign returns Addition
	 *     Assign.Assign_1_0 returns Addition
	 *     Implie returns Addition
	 *     Implie.Implie_1_0 returns Addition
	 *     OrExpression returns Addition
	 *     OrExpression.OrExpression_1_0 returns Addition
	 *     AndExpression returns Addition
	 *     AndExpression.AndExpression_1_0 returns Addition
	 *     ComparisonOperators returns Addition
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Addition
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Addition
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Addition
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Addition
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Addition
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_1_0_0_0_0 returns Addition
	 *     Addition.Minus_1_0_0_1_0 returns Addition
	 *     Multiplication returns Addition
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Addition
	 *     Multiplication.Divide_1_0_0_1_0 returns Addition
	 *     Multiplication.Modulo_1_0_0_2_0 returns Addition
	 *     Unary returns Addition
	 *     UnaryExpressionNotPlusMinus returns Addition
	 *     PrimaryExpression returns Addition
	 *
	 * Constraint:
	 *     (left=Addition_Addition_1_0_0_0_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Assign returns Minus
	 *     Assign.Assign_1_0 returns Minus
	 *     Implie returns Minus
	 *     Implie.Implie_1_0 returns Minus
	 *     OrExpression returns Minus
	 *     OrExpression.OrExpression_1_0 returns Minus
	 *     AndExpression returns Minus
	 *     AndExpression.AndExpression_1_0 returns Minus
	 *     ComparisonOperators returns Minus
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Minus
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Minus
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Minus
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Minus
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Minus
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Addition_1_0_0_0_0 returns Minus
	 *     Addition.Minus_1_0_0_1_0 returns Minus
	 *     Multiplication returns Minus
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Minus
	 *     Multiplication.Divide_1_0_0_1_0 returns Minus
	 *     Multiplication.Modulo_1_0_0_2_0 returns Minus
	 *     Unary returns Minus
	 *     UnaryExpressionNotPlusMinus returns Minus
	 *     PrimaryExpression returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_0_1_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     Assign returns AndExpression
	 *     Assign.Assign_1_0 returns AndExpression
	 *     Implie returns AndExpression
	 *     Implie.Implie_1_0 returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     ComparisonOperators returns AndExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns AndExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns AndExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns AndExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns AndExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns AndExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns AndExpression
	 *     Addition returns AndExpression
	 *     Addition.Addition_1_0_0_0_0 returns AndExpression
	 *     Addition.Minus_1_0_0_1_0 returns AndExpression
	 *     Multiplication returns AndExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns AndExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns AndExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns AndExpression
	 *     Unary returns AndExpression
	 *     UnaryExpressionNotPlusMinus returns AndExpression
	 *     PrimaryExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=ComparisonOperators)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightComparisonOperatorsParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Assign
	 *     Assign returns Assign
	 *     Assign.Assign_1_0 returns Assign
	 *     Implie returns Assign
	 *     Implie.Implie_1_0 returns Assign
	 *     OrExpression returns Assign
	 *     OrExpression.OrExpression_1_0 returns Assign
	 *     AndExpression returns Assign
	 *     AndExpression.AndExpression_1_0 returns Assign
	 *     ComparisonOperators returns Assign
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Assign
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Assign
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Assign
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Assign
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Assign
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Assign
	 *     Addition returns Assign
	 *     Addition.Addition_1_0_0_0_0 returns Assign
	 *     Addition.Minus_1_0_0_1_0 returns Assign
	 *     Multiplication returns Assign
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Assign
	 *     Multiplication.Divide_1_0_0_1_0 returns Assign
	 *     Multiplication.Modulo_1_0_0_2_0 returns Assign
	 *     Unary returns Assign
	 *     UnaryExpressionNotPlusMinus returns Assign
	 *     PrimaryExpression returns Assign
	 *
	 * Constraint:
	 *     (left=Assign_Assign_1_0 right=Implie)
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.ASSIGN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.ASSIGN__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.ASSIGN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.ASSIGN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignAccess().getAssignLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignAccess().getRightImplieParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID propertyType=VarType range=Range?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolLiteral
	 *     Assign returns BoolLiteral
	 *     Assign.Assign_1_0 returns BoolLiteral
	 *     Implie returns BoolLiteral
	 *     Implie.Implie_1_0 returns BoolLiteral
	 *     OrExpression returns BoolLiteral
	 *     OrExpression.OrExpression_1_0 returns BoolLiteral
	 *     AndExpression returns BoolLiteral
	 *     AndExpression.AndExpression_1_0 returns BoolLiteral
	 *     ComparisonOperators returns BoolLiteral
	 *     ComparisonOperators.GT_1_0_0_0_0 returns BoolLiteral
	 *     ComparisonOperators.LT_1_0_0_1_0 returns BoolLiteral
	 *     ComparisonOperators.GE_1_0_0_2_0 returns BoolLiteral
	 *     ComparisonOperators.LE_1_0_0_3_0 returns BoolLiteral
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns BoolLiteral
	 *     ComparisonOperators.NE_1_0_0_5_0 returns BoolLiteral
	 *     Addition returns BoolLiteral
	 *     Addition.Addition_1_0_0_0_0 returns BoolLiteral
	 *     Addition.Minus_1_0_0_1_0 returns BoolLiteral
	 *     Multiplication returns BoolLiteral
	 *     Multiplication.Multiplication_1_0_0_0_0 returns BoolLiteral
	 *     Multiplication.Divide_1_0_0_1_0 returns BoolLiteral
	 *     Multiplication.Modulo_1_0_0_2_0 returns BoolLiteral
	 *     Unary returns BoolLiteral
	 *     UnaryExpressionNotPlusMinus returns BoolLiteral
	 *     PrimaryExpression returns BoolLiteral
	 *     LiteralOrIdentifier returns BoolLiteral
	 *     Literal returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     boolLiteral=BOOLEAN
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.BOOL_LITERAL__BOOL_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.BOOL_LITERAL__BOOL_LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolLiteralAccess().getBoolLiteralBOOLEANTerminalRuleCall_0(), semanticObject.getBoolLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EQ
	 *     Assign returns EQ
	 *     Assign.Assign_1_0 returns EQ
	 *     Implie returns EQ
	 *     Implie.Implie_1_0 returns EQ
	 *     OrExpression returns EQ
	 *     OrExpression.OrExpression_1_0 returns EQ
	 *     AndExpression returns EQ
	 *     AndExpression.AndExpression_1_0 returns EQ
	 *     ComparisonOperators returns EQ
	 *     ComparisonOperators.GT_1_0_0_0_0 returns EQ
	 *     ComparisonOperators.LT_1_0_0_1_0 returns EQ
	 *     ComparisonOperators.GE_1_0_0_2_0 returns EQ
	 *     ComparisonOperators.LE_1_0_0_3_0 returns EQ
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns EQ
	 *     ComparisonOperators.NE_1_0_0_5_0 returns EQ
	 *     Addition returns EQ
	 *     Addition.Addition_1_0_0_0_0 returns EQ
	 *     Addition.Minus_1_0_0_1_0 returns EQ
	 *     Multiplication returns EQ
	 *     Multiplication.Multiplication_1_0_0_0_0 returns EQ
	 *     Multiplication.Divide_1_0_0_1_0 returns EQ
	 *     Multiplication.Modulo_1_0_0_2_0 returns EQ
	 *     Unary returns EQ
	 *     UnaryExpressionNotPlusMinus returns EQ
	 *     PrimaryExpression returns EQ
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_EQ_1_0_0_4_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, EQ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.EQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.EQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.EQ__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.EQ__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getEQLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GE
	 *     Assign returns GE
	 *     Assign.Assign_1_0 returns GE
	 *     Implie returns GE
	 *     Implie.Implie_1_0 returns GE
	 *     OrExpression returns GE
	 *     OrExpression.OrExpression_1_0 returns GE
	 *     AndExpression returns GE
	 *     AndExpression.AndExpression_1_0 returns GE
	 *     ComparisonOperators returns GE
	 *     ComparisonOperators.GT_1_0_0_0_0 returns GE
	 *     ComparisonOperators.LT_1_0_0_1_0 returns GE
	 *     ComparisonOperators.GE_1_0_0_2_0 returns GE
	 *     ComparisonOperators.LE_1_0_0_3_0 returns GE
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns GE
	 *     ComparisonOperators.NE_1_0_0_5_0 returns GE
	 *     Addition returns GE
	 *     Addition.Addition_1_0_0_0_0 returns GE
	 *     Addition.Minus_1_0_0_1_0 returns GE
	 *     Multiplication returns GE
	 *     Multiplication.Multiplication_1_0_0_0_0 returns GE
	 *     Multiplication.Divide_1_0_0_1_0 returns GE
	 *     Multiplication.Modulo_1_0_0_2_0 returns GE
	 *     Unary returns GE
	 *     UnaryExpressionNotPlusMinus returns GE
	 *     PrimaryExpression returns GE
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_GE_1_0_0_2_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, GE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.GE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.GE__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.GE__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.GE__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getGELeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GT
	 *     Assign returns GT
	 *     Assign.Assign_1_0 returns GT
	 *     Implie returns GT
	 *     Implie.Implie_1_0 returns GT
	 *     OrExpression returns GT
	 *     OrExpression.OrExpression_1_0 returns GT
	 *     AndExpression returns GT
	 *     AndExpression.AndExpression_1_0 returns GT
	 *     ComparisonOperators returns GT
	 *     ComparisonOperators.GT_1_0_0_0_0 returns GT
	 *     ComparisonOperators.LT_1_0_0_1_0 returns GT
	 *     ComparisonOperators.GE_1_0_0_2_0 returns GT
	 *     ComparisonOperators.LE_1_0_0_3_0 returns GT
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns GT
	 *     ComparisonOperators.NE_1_0_0_5_0 returns GT
	 *     Addition returns GT
	 *     Addition.Addition_1_0_0_0_0 returns GT
	 *     Addition.Minus_1_0_0_1_0 returns GT
	 *     Multiplication returns GT
	 *     Multiplication.Multiplication_1_0_0_0_0 returns GT
	 *     Multiplication.Divide_1_0_0_1_0 returns GT
	 *     Multiplication.Modulo_1_0_0_2_0 returns GT
	 *     Unary returns GT
	 *     UnaryExpressionNotPlusMinus returns GT
	 *     PrimaryExpression returns GT
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_GT_1_0_0_0_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, GT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.GT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.GT__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.GT__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.GT__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getGTLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LE
	 *     Assign returns LE
	 *     Assign.Assign_1_0 returns LE
	 *     Implie returns LE
	 *     Implie.Implie_1_0 returns LE
	 *     OrExpression returns LE
	 *     OrExpression.OrExpression_1_0 returns LE
	 *     AndExpression returns LE
	 *     AndExpression.AndExpression_1_0 returns LE
	 *     ComparisonOperators returns LE
	 *     ComparisonOperators.GT_1_0_0_0_0 returns LE
	 *     ComparisonOperators.LT_1_0_0_1_0 returns LE
	 *     ComparisonOperators.GE_1_0_0_2_0 returns LE
	 *     ComparisonOperators.LE_1_0_0_3_0 returns LE
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns LE
	 *     ComparisonOperators.NE_1_0_0_5_0 returns LE
	 *     Addition returns LE
	 *     Addition.Addition_1_0_0_0_0 returns LE
	 *     Addition.Minus_1_0_0_1_0 returns LE
	 *     Multiplication returns LE
	 *     Multiplication.Multiplication_1_0_0_0_0 returns LE
	 *     Multiplication.Divide_1_0_0_1_0 returns LE
	 *     Multiplication.Modulo_1_0_0_2_0 returns LE
	 *     Unary returns LE
	 *     UnaryExpressionNotPlusMinus returns LE
	 *     PrimaryExpression returns LE
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_LE_1_0_0_3_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, LE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.LE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.LE__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.LE__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.LE__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getLELeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LT
	 *     Assign returns LT
	 *     Assign.Assign_1_0 returns LT
	 *     Implie returns LT
	 *     Implie.Implie_1_0 returns LT
	 *     OrExpression returns LT
	 *     OrExpression.OrExpression_1_0 returns LT
	 *     AndExpression returns LT
	 *     AndExpression.AndExpression_1_0 returns LT
	 *     ComparisonOperators returns LT
	 *     ComparisonOperators.GT_1_0_0_0_0 returns LT
	 *     ComparisonOperators.LT_1_0_0_1_0 returns LT
	 *     ComparisonOperators.GE_1_0_0_2_0 returns LT
	 *     ComparisonOperators.LE_1_0_0_3_0 returns LT
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns LT
	 *     ComparisonOperators.NE_1_0_0_5_0 returns LT
	 *     Addition returns LT
	 *     Addition.Addition_1_0_0_0_0 returns LT
	 *     Addition.Minus_1_0_0_1_0 returns LT
	 *     Multiplication returns LT
	 *     Multiplication.Multiplication_1_0_0_0_0 returns LT
	 *     Multiplication.Divide_1_0_0_1_0 returns LT
	 *     Multiplication.Modulo_1_0_0_2_0 returns LT
	 *     Unary returns LT
	 *     UnaryExpressionNotPlusMinus returns LT
	 *     PrimaryExpression returns LT
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_LT_1_0_0_1_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, LT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.LT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.LT__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.LT__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.LT__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getLTLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NE
	 *     Assign returns NE
	 *     Assign.Assign_1_0 returns NE
	 *     Implie returns NE
	 *     Implie.Implie_1_0 returns NE
	 *     OrExpression returns NE
	 *     OrExpression.OrExpression_1_0 returns NE
	 *     AndExpression returns NE
	 *     AndExpression.AndExpression_1_0 returns NE
	 *     ComparisonOperators returns NE
	 *     ComparisonOperators.GT_1_0_0_0_0 returns NE
	 *     ComparisonOperators.LT_1_0_0_1_0 returns NE
	 *     ComparisonOperators.GE_1_0_0_2_0 returns NE
	 *     ComparisonOperators.LE_1_0_0_3_0 returns NE
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns NE
	 *     ComparisonOperators.NE_1_0_0_5_0 returns NE
	 *     Addition returns NE
	 *     Addition.Addition_1_0_0_0_0 returns NE
	 *     Addition.Minus_1_0_0_1_0 returns NE
	 *     Multiplication returns NE
	 *     Multiplication.Multiplication_1_0_0_0_0 returns NE
	 *     Multiplication.Divide_1_0_0_1_0 returns NE
	 *     Multiplication.Modulo_1_0_0_2_0 returns NE
	 *     Unary returns NE
	 *     UnaryExpressionNotPlusMinus returns NE
	 *     PrimaryExpression returns NE
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_NE_1_0_0_5_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, NE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.NE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.NE__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.NE__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.NE__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getNELeftAction_1_0_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     (name=ID attributes+=Attribute+ init=Init systemInvariants+=SystemInvariant* messageConstraints+=MessageConstraint*)
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Identifier
	 *     Assign returns Identifier
	 *     Assign.Assign_1_0 returns Identifier
	 *     Implie returns Identifier
	 *     Implie.Implie_1_0 returns Identifier
	 *     OrExpression returns Identifier
	 *     OrExpression.OrExpression_1_0 returns Identifier
	 *     AndExpression returns Identifier
	 *     AndExpression.AndExpression_1_0 returns Identifier
	 *     ComparisonOperators returns Identifier
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Identifier
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Identifier
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Identifier
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Identifier
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Identifier
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Identifier
	 *     Addition returns Identifier
	 *     Addition.Addition_1_0_0_0_0 returns Identifier
	 *     Addition.Minus_1_0_0_1_0 returns Identifier
	 *     Multiplication returns Identifier
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Identifier
	 *     Multiplication.Divide_1_0_0_1_0 returns Identifier
	 *     Multiplication.Modulo_1_0_0_2_0 returns Identifier
	 *     Unary returns Identifier
	 *     UnaryExpressionNotPlusMinus returns Identifier
	 *     PrimaryExpression returns Identifier
	 *     LiteralOrIdentifier returns Identifier
	 *     Identifier returns Identifier
	 *
	 * Constraint:
	 *     ref=[Attribute|ID]
	 */
	protected void sequence_Identifier(ISerializationContext context, Identifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.IDENTIFIER__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.IDENTIFIER__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifierAccess().getRefAttributeIDTerminalRuleCall_0_1(), semanticObject.eGet(ConstLangPackage.Literals.IDENTIFIER__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Implie
	 *     Assign returns Implie
	 *     Assign.Assign_1_0 returns Implie
	 *     Implie returns Implie
	 *     Implie.Implie_1_0 returns Implie
	 *     OrExpression returns Implie
	 *     OrExpression.OrExpression_1_0 returns Implie
	 *     AndExpression returns Implie
	 *     AndExpression.AndExpression_1_0 returns Implie
	 *     ComparisonOperators returns Implie
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Implie
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Implie
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Implie
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Implie
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Implie
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Implie
	 *     Addition returns Implie
	 *     Addition.Addition_1_0_0_0_0 returns Implie
	 *     Addition.Minus_1_0_0_1_0 returns Implie
	 *     Multiplication returns Implie
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Implie
	 *     Multiplication.Divide_1_0_0_1_0 returns Implie
	 *     Multiplication.Modulo_1_0_0_2_0 returns Implie
	 *     Unary returns Implie
	 *     UnaryExpressionNotPlusMinus returns Implie
	 *     PrimaryExpression returns Implie
	 *
	 * Constraint:
	 *     (left=Implie_Implie_1_0 right=OrExpression)
	 */
	protected void sequence_Implie(ISerializationContext context, Implie semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.IMPLIE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.IMPLIE__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.IMPLIE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.IMPLIE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplieAccess().getImplieLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImplieAccess().getRightOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Init returns Init
	 *
	 * Constraint:
	 *     expressions+=Expression+
	 */
	protected void sequence_Init(ISerializationContext context, Init semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntLiteral
	 *     Assign returns IntLiteral
	 *     Assign.Assign_1_0 returns IntLiteral
	 *     Implie returns IntLiteral
	 *     Implie.Implie_1_0 returns IntLiteral
	 *     OrExpression returns IntLiteral
	 *     OrExpression.OrExpression_1_0 returns IntLiteral
	 *     AndExpression returns IntLiteral
	 *     AndExpression.AndExpression_1_0 returns IntLiteral
	 *     ComparisonOperators returns IntLiteral
	 *     ComparisonOperators.GT_1_0_0_0_0 returns IntLiteral
	 *     ComparisonOperators.LT_1_0_0_1_0 returns IntLiteral
	 *     ComparisonOperators.GE_1_0_0_2_0 returns IntLiteral
	 *     ComparisonOperators.LE_1_0_0_3_0 returns IntLiteral
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns IntLiteral
	 *     ComparisonOperators.NE_1_0_0_5_0 returns IntLiteral
	 *     Addition returns IntLiteral
	 *     Addition.Addition_1_0_0_0_0 returns IntLiteral
	 *     Addition.Minus_1_0_0_1_0 returns IntLiteral
	 *     Multiplication returns IntLiteral
	 *     Multiplication.Multiplication_1_0_0_0_0 returns IntLiteral
	 *     Multiplication.Divide_1_0_0_1_0 returns IntLiteral
	 *     Multiplication.Modulo_1_0_0_2_0 returns IntLiteral
	 *     Unary returns IntLiteral
	 *     UnaryExpressionNotPlusMinus returns IntLiteral
	 *     PrimaryExpression returns IntLiteral
	 *     LiteralOrIdentifier returns IntLiteral
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     intLiteral=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.INT_LITERAL__INT_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.INT_LITERAL__INT_LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getIntLiteralINTTerminalRuleCall_0(), semanticObject.getIntLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MessageConstraint returns MessageConstraint
	 *
	 * Constraint:
	 *     (name=ID params+=Attribute* WhereToApply=WhereToApplyEnum? preConstraints=Expression? postConstraints=Expression)
	 */
	protected void sequence_MessageConstraint(ISerializationContext context, MessageConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Divide
	 *     Assign returns Divide
	 *     Assign.Assign_1_0 returns Divide
	 *     Implie returns Divide
	 *     Implie.Implie_1_0 returns Divide
	 *     OrExpression returns Divide
	 *     OrExpression.OrExpression_1_0 returns Divide
	 *     AndExpression returns Divide
	 *     AndExpression.AndExpression_1_0 returns Divide
	 *     ComparisonOperators returns Divide
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Divide
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Divide
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Divide
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Divide
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Divide
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Divide
	 *     Addition returns Divide
	 *     Addition.Addition_1_0_0_0_0 returns Divide
	 *     Addition.Minus_1_0_0_1_0 returns Divide
	 *     Multiplication returns Divide
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Divide
	 *     Multiplication.Divide_1_0_0_1_0 returns Divide
	 *     Multiplication.Modulo_1_0_0_2_0 returns Divide
	 *     Unary returns Divide
	 *     UnaryExpressionNotPlusMinus returns Divide
	 *     PrimaryExpression returns Divide
	 *
	 * Constraint:
	 *     (left=Multiplication_Divide_1_0_0_1_0 right=Unary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.DIVIDE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.DIVIDE__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.DIVIDE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.DIVIDE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivideLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightUnaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Modulo
	 *     Assign returns Modulo
	 *     Assign.Assign_1_0 returns Modulo
	 *     Implie returns Modulo
	 *     Implie.Implie_1_0 returns Modulo
	 *     OrExpression returns Modulo
	 *     OrExpression.OrExpression_1_0 returns Modulo
	 *     AndExpression returns Modulo
	 *     AndExpression.AndExpression_1_0 returns Modulo
	 *     ComparisonOperators returns Modulo
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Modulo
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Modulo
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Modulo
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Modulo
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Modulo
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Modulo
	 *     Addition returns Modulo
	 *     Addition.Addition_1_0_0_0_0 returns Modulo
	 *     Addition.Minus_1_0_0_1_0 returns Modulo
	 *     Multiplication returns Modulo
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Modulo
	 *     Multiplication.Divide_1_0_0_1_0 returns Modulo
	 *     Multiplication.Modulo_1_0_0_2_0 returns Modulo
	 *     Unary returns Modulo
	 *     UnaryExpressionNotPlusMinus returns Modulo
	 *     PrimaryExpression returns Modulo
	 *
	 * Constraint:
	 *     (left=Multiplication_Modulo_1_0_0_2_0 right=Unary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Modulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.MODULO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.MODULO__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.MODULO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.MODULO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getModuloLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightUnaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Multiplication
	 *     Assign returns Multiplication
	 *     Assign.Assign_1_0 returns Multiplication
	 *     Implie returns Multiplication
	 *     Implie.Implie_1_0 returns Multiplication
	 *     OrExpression returns Multiplication
	 *     OrExpression.OrExpression_1_0 returns Multiplication
	 *     AndExpression returns Multiplication
	 *     AndExpression.AndExpression_1_0 returns Multiplication
	 *     ComparisonOperators returns Multiplication
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Multiplication
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Multiplication
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Multiplication
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Multiplication
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Multiplication
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Multiplication
	 *     Addition returns Multiplication
	 *     Addition.Addition_1_0_0_0_0 returns Multiplication
	 *     Addition.Minus_1_0_0_1_0 returns Multiplication
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Multiplication
	 *     Multiplication.Divide_1_0_0_1_0 returns Multiplication
	 *     Multiplication.Modulo_1_0_0_2_0 returns Multiplication
	 *     Unary returns Multiplication
	 *     UnaryExpressionNotPlusMinus returns Multiplication
	 *     PrimaryExpression returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0_0_0_0 right=Unary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightUnaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotBooleanExpression
	 *     Assign returns NotBooleanExpression
	 *     Assign.Assign_1_0 returns NotBooleanExpression
	 *     Implie returns NotBooleanExpression
	 *     Implie.Implie_1_0 returns NotBooleanExpression
	 *     OrExpression returns NotBooleanExpression
	 *     OrExpression.OrExpression_1_0 returns NotBooleanExpression
	 *     AndExpression returns NotBooleanExpression
	 *     AndExpression.AndExpression_1_0 returns NotBooleanExpression
	 *     ComparisonOperators returns NotBooleanExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns NotBooleanExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns NotBooleanExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns NotBooleanExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns NotBooleanExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns NotBooleanExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns NotBooleanExpression
	 *     Addition returns NotBooleanExpression
	 *     Addition.Addition_1_0_0_0_0 returns NotBooleanExpression
	 *     Addition.Minus_1_0_0_1_0 returns NotBooleanExpression
	 *     Multiplication returns NotBooleanExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns NotBooleanExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns NotBooleanExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns NotBooleanExpression
	 *     Unary returns NotBooleanExpression
	 *     UnaryExpressionNotPlusMinus returns NotBooleanExpression
	 *     NotBooleanExpression returns NotBooleanExpression
	 *     PrimaryExpression returns NotBooleanExpression
	 *
	 * Constraint:
	 *     exp=PrimaryExpression
	 */
	protected void sequence_NotBooleanExpression(ISerializationContext context, NotBooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotBooleanExpressionAccess().getExpPrimaryExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     Assign returns OrExpression
	 *     Assign.Assign_1_0 returns OrExpression
	 *     Implie returns OrExpression
	 *     Implie.Implie_1_0 returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     ComparisonOperators returns OrExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns OrExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns OrExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns OrExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns OrExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns OrExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns OrExpression
	 *     Addition returns OrExpression
	 *     Addition.Addition_1_0_0_0_0 returns OrExpression
	 *     Addition.Minus_1_0_0_1_0 returns OrExpression
	 *     Multiplication returns OrExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns OrExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns OrExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns OrExpression
	 *     Unary returns OrExpression
	 *     UnaryExpressionNotPlusMinus returns OrExpression
	 *     PrimaryExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (name=ID propertyType=VarType)
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.PARAM__NAME));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.PARAM__PROPERTY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.PARAM__PROPERTY_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParamAccess().getPropertyTypeVarTypeEnumRuleCall_2_0(), semanticObject.getPropertyType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     paramname=[Param|ID]
	 */
	protected void sequence_Parameter(ISerializationContext context, umlrtsyntesizer.constLang.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.PARAMETER__PARAMNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.PARAMETER__PARAMNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getParamnameParamIDTerminalRuleCall_0_1(), semanticObject.eGet(ConstLangPackage.Literals.PARAMETER__PARAMNAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (from=Value to=Value)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.RANGE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.RANGE__FROM));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.RANGE__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.RANGE__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getFromValueParserRuleCall_1_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getRangeAccess().getToValueParserRuleCall_3_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RealLiteral returns RealLiteral
	 *     Expression returns RealLiteral
	 *     Assign returns RealLiteral
	 *     Assign.Assign_1_0 returns RealLiteral
	 *     Implie returns RealLiteral
	 *     Implie.Implie_1_0 returns RealLiteral
	 *     OrExpression returns RealLiteral
	 *     OrExpression.OrExpression_1_0 returns RealLiteral
	 *     AndExpression returns RealLiteral
	 *     AndExpression.AndExpression_1_0 returns RealLiteral
	 *     ComparisonOperators returns RealLiteral
	 *     ComparisonOperators.GT_1_0_0_0_0 returns RealLiteral
	 *     ComparisonOperators.LT_1_0_0_1_0 returns RealLiteral
	 *     ComparisonOperators.GE_1_0_0_2_0 returns RealLiteral
	 *     ComparisonOperators.LE_1_0_0_3_0 returns RealLiteral
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns RealLiteral
	 *     ComparisonOperators.NE_1_0_0_5_0 returns RealLiteral
	 *     Addition returns RealLiteral
	 *     Addition.Addition_1_0_0_0_0 returns RealLiteral
	 *     Addition.Minus_1_0_0_1_0 returns RealLiteral
	 *     Multiplication returns RealLiteral
	 *     Multiplication.Multiplication_1_0_0_0_0 returns RealLiteral
	 *     Multiplication.Divide_1_0_0_1_0 returns RealLiteral
	 *     Multiplication.Modulo_1_0_0_2_0 returns RealLiteral
	 *     Unary returns RealLiteral
	 *     UnaryExpressionNotPlusMinus returns RealLiteral
	 *     PrimaryExpression returns RealLiteral
	 *     LiteralOrIdentifier returns RealLiteral
	 *     Literal returns RealLiteral
	 *
	 * Constraint:
	 *     (intPart=INT decimalPart=INT)
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.REAL_LITERAL__INT_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.REAL_LITERAL__INT_PART));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.REAL_LITERAL__DECIMAL_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.REAL_LITERAL__DECIMAL_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getIntPartINTTerminalRuleCall_0_0(), semanticObject.getIntPart());
		feeder.accept(grammarAccess.getRealLiteralAccess().getDecimalPartINTTerminalRuleCall_2_0(), semanticObject.getDecimalPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemInvariant returns SystemInvariant
	 *
	 * Constraint:
	 *     (name=ID invariantExp=Expression)
	 */
	protected void sequence_SystemInvariant(ISerializationContext context, SystemInvariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.SYSTEM_INVARIANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.SYSTEM_INVARIANT__NAME));
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.SYSTEM_INVARIANT__INVARIANT_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.SYSTEM_INVARIANT__INVARIANT_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSystemInvariantAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSystemInvariantAccess().getInvariantExpExpressionParserRuleCall_2_1_0(), semanticObject.getInvariantExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     Assign returns UnaryExpression
	 *     Assign.Assign_1_0 returns UnaryExpression
	 *     Implie returns UnaryExpression
	 *     Implie.Implie_1_0 returns UnaryExpression
	 *     OrExpression returns UnaryExpression
	 *     OrExpression.OrExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.AndExpression_1_0 returns UnaryExpression
	 *     ComparisonOperators returns UnaryExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns UnaryExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns UnaryExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns UnaryExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns UnaryExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns UnaryExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns UnaryExpression
	 *     Addition returns UnaryExpression
	 *     Addition.Addition_1_0_0_0_0 returns UnaryExpression
	 *     Addition.Minus_1_0_0_1_0 returns UnaryExpression
	 *     Multiplication returns UnaryExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns UnaryExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns UnaryExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns UnaryExpression
	 *     Unary returns UnaryExpression
	 *     UnaryExpressionNotPlusMinus returns UnaryExpression
	 *     PrimaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     exp=Unary
	 */
	protected void sequence_Unary(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstLangPackage.Literals.UNARY_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstLangPackage.Literals.UNARY_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getExpUnaryParserRuleCall_1_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     ((minues?='-'? value=INT) | fixedPointValue=RealLiteral)
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
